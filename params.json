{"name":"Munki-pkg","tagline":"Repo for the munkipkg tool and example projects","body":"#munkipkg\r\n\r\n##Introduction\r\n\r\nmunkipkg is a simple tool for building packages in a consistent, repeatable manner from source files and scripts in a project directory.\r\n\r\nWhile you can use munkipkg to generate packages for use with Munki (https://www.munki.org/munki/), the packages munkipkg builds are just normal Apple installer packages usable anywhere you can use Apple installer packages.\r\n\r\nFiles, scripts, and metadata are stored in a way that is easy to track and manage using a version control system like git.\r\n\r\nAnother tool that solves a similar problem is Joe Block's **The Luggage** (https://github.com/unixorn/luggage). If you are happily using The Luggage, you can probably safely ignore this tool.\r\n\r\n**autopkg** (https://github.com/autopkg/autopkg) is another tool that has some overlap here. It's definitely possible to use autopkg to build packages from files and scripts on your local disk. See https://managingosx.wordpress.com/2015/07/30/using-autopkg-for-general-purpose-packaging/ and https://github.com/gregneagle/autopkg-packaging-demo for examples on how to do this.\r\n\r\nSo why consider using munkipkg? It's simple and self-contained, with no external dependencies. It can use JSON for its build settings file/data, instead of Makefile systax or XML plists. It does not install a root-level system daemon as does autopkg. It can easily build distribution-style packages and can sign them. Finally, munkipkg can import existing packages.\r\n\r\n##Basic operation\r\n\r\nmunkipkg builds flat packages using Apple's pkgbuild and productbuild tools.\r\n\r\n###Package project directories\r\n\r\nmunkipkg builds packages from a \"package project directory\". At its simplest, a package project directory is a directory containing a \"payload\" directory, which itself contains the files to be packaged. More typically, the directory also contains a \"build-info.plist\" file containing specific settings for the build. The package project directory may also contain a \"scripts\" directory containing any scripts (and, optionally, additional files used by the scripts) to be included in the package.\r\n\r\n\r\n###Package project directory layout\r\n```\r\nproject_dir/\r\n    build-info.plist\r\n    payload/\r\n    scripts/\r\n```\r\n\r\n###Creating a new project\r\n\r\nmunkipkg can create an empty package project directory for you:\r\n\r\n`munkipkg --create Foo`\r\n\r\n...will create a new package project directory named \"Foo\" in the current working directory, complete with a starter build-info.plist, empty payload and scripts directories, and a .gitignore file to cause git to ignore the build/ directory that is created when a project is built.\r\n\r\nOnce you have a project directory, you simply copy the files you wish to package into the payload directory, and add a preinstall and/or postinstall script to the scripts directory. You may also wish to edit the build-info.plist.\r\n\r\n###Importing an existing package\r\n\r\nAnother way to create a package project is to import an existing package:\r\n\r\n`munkipkg --import /path/to/foo.pkg Foo`\r\n\r\n...will create a new package project directory named \"Foo\" in the current working directory, with payload, scripts and build-info extracted from foo.pkg.\r\nComplex or non-standard packages may not be extracted with 100% fidelity, and not all package formats are supported. Specifically, metapackages are not supported, and distribution packages containing multiple sub-packages are not supported. In these cases, consider importing the individual sub-packages.\r\n\r\n\r\n###Building a package\r\n\r\nThis is the central task of munkipkg.\r\n\r\n`munkipkg path/to/package_project_directory`\r\n\r\nCauses munkipkg to build the package defined in package_project_directory. The built package is created in a build/ directory inside the project directory.\r\n\r\n###build-info\r\n\r\nBuild options are stored in a file at the root of the package project. XML plist and JSON formats are supported. A build-info file is not strictly required, and a build will use default values if this file is missing.\r\n\r\n####build-info.plist\r\n\r\nThis must be in XML (text) format. Binary plists are not supported. For a new project created with `munkipkg --create Foo`, the build-info.plist looks like this:\r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\r\n<plist version=\"1.0\">\r\n<dict>\r\n    <key>distribution_style</key>\r\n    <false/>\r\n    <key>identifier</key>\r\n    <string>com.github.munki.pkg.Foo</string>\r\n    <key>install_location</key>\r\n    <string>/</string>\r\n    <key>name</key>\r\n    <string>Foo.pkg</string>\r\n    <key>ownership</key>\r\n    <string>recommended</string>\r\n    <key>postinstall_action</key>\r\n    <string>none</string>\r\n    <key>suppress_bundle_relocation</key>\r\n    <true/>\r\n    <key>version</key>\r\n    <string>1.0</string>\r\n</dict>\r\n</plist>\r\n```\r\n\r\n####build-info.json\r\n\r\nAlternately, you may specify build-info in JSON format. A new project created with `munkipkg --create --json Foo` would have this build-info.json file:\r\n\r\n```\r\n{\r\n    \"ownership\": \"recommended\",\r\n    \"suppress_bundle_relocation\": true,\r\n    \"identifier\": \"com.github.munki.pkg.Foo\",\r\n    \"postinstall_action\": \"none\",\r\n    \"distribution_style\": false,\r\n    \"version\": \"1.0\",\r\n    \"name\": \"Foo.pkg\",\r\n    \"install_location\": \"/\"\r\n}\r\n```\r\nIf both build-info.plist and build-info.json are present, the plist file will be used; the json file will be ignored.\r\n\r\n\r\n####build-info keys\r\n\r\n**distribution_style**  \r\nBoolean: true or false. Defaults to false. If present and true, package built will be a \"distribution-style\" package.\r\n\r\n**identifier**  \r\nString containing the package identifier. If this is missing, one is constructed using the name of the package project directory.\r\n\r\n**install_location**  \r\nString. Path to the intended install location of the payload on the target disk. Defaults to \"/\".\r\n\r\n**name**  \r\nString containing the package name. If this is missing, one is constructed using the name of the package project directory.\r\n\r\n**ownership**  \r\nString. One of \"recommended\", \"preserve\", or \"preserve-other\". Defaults to \"recommended\". See the man page for pkgbuild for a description of the ownership options.\r\n\r\n**postinstall_action**  \r\nString. One of \"none\", \"logout\", or \"restart\". Defaults to \"none\".\r\n\r\n**suppress\\_bundle\\_relocation**  \r\nBoolean: true or false. Defaults to true. If present and false, bundle relocation will be allowed, which causes the Installer to update bundles found in locations other than their default location. For deploying software in a managed environment, this is rarely what you want.\r\n\r\n**version**  \r\nA string representation of the version number. Defaults to \"1.0\".\r\n\r\n**signing_info**  \r\nDictionary of signing options. See below.\r\n\r\n\r\n###Payload-free packages\r\n\r\nYou can use this tool to build payload-free packages in two variants.\r\n\r\nIf there is no payload folder at all, `pkgbuild` is called with the `--nopayload` option. The resulting package will not leave a receipt when installed.\r\n\r\nIf the payload folder exists, but is empty, you'll get a \"pseudo-payload-free\" package. No files will be installed, but a receipt will be left. This is often the more useful option if you need to track if the package has been installed on machines you manage.\r\n\r\n\r\n###Package signing\r\n\r\nYou may sign packages as part of the build process by adding a signing\\_info dictionary to the build\\_info.plist:\r\n\r\n```\r\n    <key>signing_info</key>\r\n    <dict>\r\n        <key>identity</key>\r\n        <string>Signing Identity Common Name</string>\r\n        <key>keychain</key>\r\n        <string>/path/to/SpecialKeychain</string>\r\n        <key>additional_cert_names</key>\r\n        <array>\r\n            <string>Intermediate CA Common Name 1</string>\r\n            <string>Intermediate CA Common Name 2</string>\r\n        </array>\r\n        <key>timestamp</key>\r\n        <true/>\r\n    </dict>\r\n```\r\n\r\nor, in JSON format in a build-info.json file:\r\n\r\n```\r\n    \"signing_info\": {\r\n        \"identity\": \"Signing Identity Common Name\",\r\n        \"keychain\": \"/path/to/SpecialKeychain\"\r\n        \"additional_cert_names\": [\"Intermediate CA Common Name 1\",\r\n                                  \"Intermediate CA Common Name 2\"],\r\n        \"timestamp\": true,\r\n    }\r\n```\r\n\r\nThe only required key/value in the signing_info dictionary is 'identity'.\r\n\r\nSee the **SIGNED PACKAGES** section of the man page for `pkgbuild` or the **SIGNED PRODUCT ARCHIVES** section of the man page for `productbuild` for more information on the signing options.\r\n\r\n\r\n###Scripts\r\n\r\nmunkipkg makes use of pkgbuild. Therefore the \"main\" scripts must be named either \"preinstall\" or \"postinstall\" (with no extensions) and must have their execute bit set. Other scripts can be called by the preinstall or postinstall scripts, but only those two scripts will be automatically called during package installation.\r\n\r\n\r\n###Additional options\r\n\r\n`--create`  \r\nCreates a new empty template package project. See [**Creating a new project**](#creating-a-new-project).\r\n\r\n`--import`  \r\n`munkipkg --import /path/to/flat.pkg /path/to/project_dir`\r\n\r\nThis option will import an existing package and convert it into a package project. project_dir must not exist; it will be created. build-info will be in plist format, add the --json option to output in JSON format instead. (IE: `munkipkg --json --import /path/to/flat.pkg /path/to/project_dir`) Not all package formats are supported.\r\n\r\n`--export-bom-info`  \r\nThis option causes munkipkg to export bom info from the built package to a file named \"Bom.txt\" in the root of the package project directory. Since git does not normally track ownership, group, or mode of tracked files, and since the \"ownership\" option to pkgbuild can also result in different owner and group of files included in the package payload, exporting this info into a text file allows you to track this metadata in git (or other version control) as well.\r\n\r\n`--sync`  \r\nThis option causes munkipkg to read the Bom.txt file, and use its information to create any missing empty directories and to set the permissions on files and directories. See [**Important git notes**](#important-git-notes) below.\r\n\r\n`--quiet`  \r\nCauses munkipkg to suppress normal output messages. Errors will still be printed to stderr.\r\n\r\n`--help`, `--version`  \r\nPrints help message and tool version, respectively.\r\n\r\n\r\n##Important git notes\r\n\r\nGit was designed to track source code. Its focus is tracking changes in the contents of files. It's not a perfect fit for tracking the parts making up a package. Specifically, git doesn't track owner or group of files or directories, and does not track any mode bits except for the execute bit for the owner. Git also does not track empty directories.\r\n\r\nThis could be a problem if you want to store package project directories in git and `git clone` them; the clone operation will fail to replicate empty directories in the package project and will fail to set the correct mode for files and directories. (Owner and group are less of an issue if you use ownership=recommended for your pkgbuild options.)\r\n\r\nThe solution to this problem is the Bom.txt file, which lists all the files and directories in the package, along with their mode, owner and group.\r\n\r\nThis file (Bom.txt) can be tracked by git.\r\n\r\nYou can create this file when building package by adding the `--export-bom-info` option. After the package is built, the Bom is extracted and `lsbom` is used to read its contents, which are written to \"Bom.txt\" at the root of the package project directory.\r\n\r\nA recommended workflow would be to build a project with `--export-bom-info` and add the Bom.txt file to the next git commit in order to preserve the data that git does not normally track.\r\n\r\nAfter doing a `git clone` or `git pull` operation, you can then use `munkipkg --sync project_name` to cause munkipkg to read the Bom.txt file and use the info within to create any missing directories and to set file and directory modes to those recorded in the bom.\r\n\r\nThis workflow is not ideal, as it requires you to remember two new manual steps (`munkipkg --export` before doing a git commit and `munkipkg --sync` after doing a `git clone` or `git pull`) but is necessary to preserve data that git otherwise ignores.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}